{
  "version": 3,
  "sources": ["../../src/utils/file-utils.ts"],
  "sourcesContent": ["import fs from \"fs\";\nimport url from \"url\";\nimport { RecordRequest } from \"../models\";\n\nexport const writeFile = (\n  filePath: string,\n  requests: RecordRequest[]\n): Promise<void> => {\n  return new Promise((resolve, reject) => {    \n    fs.writeFile(filePath, JSON.stringify({ requests }), (err) => {\n      if (err) reject(err);\n      else resolve();\n    });\n  });\n};\n\nexport const removeFile = (filePath: string): Promise<void> => {\n  return new Promise((resolve, reject) => {\n    fs.unlink(filePath, (err) => {\n      if (err) reject(err);\n      else resolve();\n    });\n  });\n};\n\nexport const readFile = (filePath: string): Promise<RecordRequest[]> => {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filePath, (err, data) => {\n      if (err) reject(err);\n      else {\n        try {\n          const requests = JSON.parse(data.toString()).requests;\n          resolve(requests);\n        } catch (e) {\n          reject(e);\n        }\n      }\n    });\n  });\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n};\n\nexport const waitForFileExists = async (\n  filePath: string,\n  currentTime = 0,\n  timeout = 10000\n): Promise<boolean> => {\n  if (fs.existsSync(filePath)) return true;\n  if (currentTime === timeout) return false;\n\n  await sleep(1000);\n\n  return await waitForFileExists(filePath, currentTime + 1000, timeout);\n};\n\nexport const getCallerFile = (): string => {\n  const err = new Error();\n  Error.prepareStackTrace = (_, stack) => stack;\n  const stack = err.stack as any;\n  Error.prepareStackTrace = undefined;\n\n  const callerFile = stack\n    .map((s) => s.getFileName())\n    .filter((s) => s && !s.includes(\"node_modules\") && !s.includes(\"internal\"))\n    .pop();\n\n  const isFileUrl = callerFile.includes(\"file:\");\n  const callerFilePath = isFileUrl ? url.fileURLToPath(callerFile) : callerFile;\n \n  return callerFilePath;\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAe;AACf,iBAAgB;AAGT,MAAM,YAAY,CACvB,UACA,aACkB;AAClB,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,sBAAG,UAAU,UAAU,KAAK,UAAU,EAAE,aAAa,CAAC,QAAQ;AAC5D,UAAI;AAAK,eAAO;AAAA;AACX;AAAA;AAAA;AAAA;AAKJ,MAAM,aAAa,CAAC,aAAoC;AAC7D,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,sBAAG,OAAO,UAAU,CAAC,QAAQ;AAC3B,UAAI;AAAK,eAAO;AAAA;AACX;AAAA;AAAA;AAAA;AAKJ,MAAM,WAAW,CAAC,aAA+C;AACtE,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,sBAAG,SAAS,UAAU,CAAC,KAAK,SAAS;AACnC,UAAI;AAAK,eAAO;AAAA,WACX;AACH,YAAI;AACF,gBAAM,WAAW,KAAK,MAAM,KAAK,YAAY;AAC7C,kBAAQ;AAAA,iBACD,GAAP;AACA,iBAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAOjB,MAAM,QAAQ,CAAC,OAA8B;AAC3C,SAAO,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS;AAAA;AAG/C,MAAM,oBAAoB,CAC/B,UACA,cAAc,GACd,UAAU,QACW;AACrB,MAAI,kBAAG,WAAW;AAAW,WAAO;AACpC,MAAI,gBAAgB;AAAS,WAAO;AAEpC,QAAM,MAAM;AAEZ,SAAO,MAAM,kBAAkB,UAAU,cAAc,KAAM;AAAA;AAGxD,MAAM,gBAAgB,MAAc;AACzC,QAAM,MAAM,IAAI;AAChB,QAAM,oBAAoB,CAAC,GAAG,WAAU;AACxC,QAAM,QAAQ,IAAI;AAClB,QAAM,oBAAoB;AAE1B,QAAM,aAAa,MAChB,IAAI,CAAC,MAAM,EAAE,eACb,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,SAAS,mBAAmB,CAAC,EAAE,SAAS,aAC9D;AAEH,QAAM,YAAY,WAAW,SAAS;AACtC,QAAM,iBAAiB,YAAY,mBAAI,cAAc,cAAc;AAEnE,SAAO;AAAA;",
  "names": []
}
